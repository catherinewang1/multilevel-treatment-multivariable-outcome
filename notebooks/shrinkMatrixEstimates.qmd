---
title: "Shrink Estimates to a 'Sparse' Matrix"
format: html
editor: source
theme: sandstone
toc: true
toc-depth: 2
execute: 
  echo: true
  warning: false
---





```{r}

suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(tidyr))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(RColorBrewer))
# suppressPackageStartupMessages(library(ebci)) # robust emp shrinkage

# source('../utils/myKmeans.R')
# source('../utils/cluster_and_ebci_shrinkage.r')


# load estimated effects
effects_list = list()
for(est_method in c('sceptre')){ # , 'poisson', 'nb')) {
  effects_list[[est_method]] = list()
  for(testsplit in c('train', 'test', 'all')) {
    
    if(est_method == 'sceptre') {path = 'sceptre/sceptre'} 
    else if(est_method == 'nb') {path = 'negativebinomial'}
    else {path = est_method}
    
    effects_list[[est_method]][[testsplit]] = 
      read.csv(sprintf('../saves/%s_effects_%s.csv',
                       path, testsplit)) |> 
      # filter(!is.na(estimate)) |>   # remove tests with NA estimates
      mutate(tstat = estimate / se) # make a tstat column = estimate / se
  }
}



method_nice_names = list('sceptre'='SCEPTRE',
                         'poisson'='Poisson',
                         'nb'     ='Negative Binomial')


# effects_df = read.csv('../saves/sceptre/sceptre_effects_all.csv')

topgenes = read.csv('../saves/sceptre/topgenes.csv')
topgrnas = read.csv('../saves/sceptre/topgrnas.csv')

gene_dev_df = read.csv('../saves/gene_deviance.csv') # df of gene importance (cols: idx, deviance, gene_name)


my_positive_control_pairs = read.csv('../saves/sceptre/positive_control_pairs.csv')
my_discovery_pairs = read.csv('../saves/sceptre/discovery_pairs.csv'       )

# select top genes and grna 
effects_all_df = read.csv('../saves/sceptre/sceptre_effects_all.csv') 
effects_df = effects_all_df |> filter(test == 'discovery') # | test == 'positive') 
topgenes = effects_df |> group_by(gene) |> summarize(sum_effects = sum(abs(estimate), na.rm = TRUE),
                                                      sd_effects = sd(estimate, na.rm = TRUE),
                                                     sig_effects = sum(significant, na.rm=TRUE),
                                                     sum_tstats  = sum(abs(estimate/se), na.rm = TRUE)) |>
                         mutate(score = scale(sum_effects) + (1/3)* scale(sd_effects) +  sig_effects) |> 
                         arrange(desc(score)) |> 
                         arrange(desc(sum_tstats))
topgrnas = effects_df |> group_by(grna) |> summarize(sum_effects = sum(abs(estimate), na.rm = TRUE),
                                                      sd_effects = sd(estimate, na.rm = TRUE),
                                                     sig_effects = sum(significant, na.rm=TRUE),
                                                     sum_tstats  = sum(abs(estimate/se), na.rm = TRUE)) |>
                         mutate(score = scale(sum_effects) + (0)* scale(sd_effects) +  sig_effects) |> 
                         arrange(desc(score)) |> 
                         arrange(desc(sum_tstats))


myRed  = colorRampPalette(brewer.pal(n = 7, name = "RdBu"))(7)[1]
myBlue = colorRampPalette(brewer.pal(n = 7, name = "RdBu"))(7)[7]
```






```{r}

#' From an effects dataframe where rows = test, cols = effects, other vals...
#' make matrices that are #perturbations x #genes shaped 
#' e.g. effects_matrix can be used in image(), heatmap(), ...
#' @param effects_df (dataframe)
#' @param save_plots_filepath (string) or NULL for no plots
make_matrices <- function(effects_df, save_plots_filepath=NULL) {
  # save_plots_filepath = '../plots/matrix/'
  # Some tests missing bc failed quality check (from sceptre)
  # fill estimate = 0, and se = 999 (for now)
  foldchange_matrix = effects_df |> # filter(grna_idx %in% 1:400 & gene_idx %in% 1:400) |> 
    dplyr::select(grna, gene, fold_change) |>
    tidyr::pivot_wider(names_from = gene, values_from = fold_change) |>
    tibble::column_to_rownames(var='grna')
  foldchange_matrix[is.na(foldchange_matrix)] = 0
  
  # fill estimate = 0, and se = 999 (for now)
  estimates_matrix = effects_df |> # filter(grna_idx %in% 1:400 & gene_idx %in% 1:400) |> 
    dplyr::select(grna, gene, estimate) |>
    tidyr::pivot_wider(names_from = gene, values_from = estimate) |>
    tibble::column_to_rownames(var='grna')
  estimates_matrix[is.na(estimates_matrix)] = 0
  
  se_matrix = effects_df |> # filter(grna_idx %in% 1:400 & gene_idx %in% 1:400) |> 
    dplyr::select(grna, gene, se) |>
    tidyr::pivot_wider(names_from = gene, values_from = se) |>
    tibble::column_to_rownames(var='grna')
  se_matrix[is.na(se_matrix)] = 999
  
  tstat_matrix = effects_df |> # filter(grna_idx %in% 1:400 & gene_idx %in% 1:400) |> 
    dplyr::select(grna, gene, tstat) |>
    tidyr::pivot_wider(names_from = gene, values_from = tstat) |>
    tibble::column_to_rownames(var='grna')
  tstat_matrix[is.na(tstat_matrix) ] = 0 # fill NA (from se) to 0 (e.g. not significant)
  
  significant_matrix = effects_df |>
    dplyr::select(grna, gene, significant) |>
    tidyr::pivot_wider(names_from = gene, values_from = significant) |>
    tibble::column_to_rownames(var='grna')
  significant_matrix[is.na(significant_matrix) ] = 0 # fill NA (from se) to 0 (e.g. not significant)
  
  
  # vis
  if(!is.null(save_plots_filepath)) {
    require(RColorBrewer)
    # Fold Change
    p = pheatmap::pheatmap(foldchange_matrix |> as.matrix(), treeheight_row = 0, treeheight_col = 0, 
                           color = colorRampPalette((brewer.pal(n = 7, name = "YlOrRd")))(100),
                           show_rownames = FALSE, show_colnames = FALSE)
    ggsave(plot = p, filename = sprintf('%s/foldchange.pdf', save_plots_filepath))
    
    # Estimates- SOME COLORS ARE CUT OFF TO MIN/MAX! range(estimates_matrix) hist(estimates_matrix |> as.matrix() |> as.vector())
    p = pheatmap::pheatmap(estimates_matrix |> as.matrix(), treeheight_row = 0, treeheight_col = 0, 
                       color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100), 
                       breaks = seq(from = -2, to = 2, length.out = 101),
                       show_rownames = FALSE, show_colnames = FALSE)
    ggsave(plot = p, filename = sprintf('%s/estimates.pdf', save_plots_filepath))
    
    
    # SE range(tstat_matrix)
    p = pheatmap::pheatmap(se_matrix |> as.matrix(), treeheight_row = 0, treeheight_col = 0, 
                       color = colorRampPalette((brewer.pal(n = 7, name = "YlOrRd")))(100), 
                       show_rownames = FALSE, show_colnames = FALSE)
    ggsave(plot = p, filename = sprintf('%s/se.pdf', save_plots_filepath))
    
     
    # T statistic- SOME COLORS ARE CUT OFF TO MIN/MAX! range(tstat_matrix) hist(tstat_matrix |> as.matrix() |> as.vector())
    p = pheatmap::pheatmap(tstat_matrix |> as.matrix(), treeheight_row = 0, treeheight_col = 0, 
                           color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100),
                           breaks = seq(from = -6, to = 6, length.out = 101),
                           show_rownames = FALSE, show_colnames = FALSE)
    ggsave(plot = p, filename = sprintf('%s/tstat.pdf', save_plots_filepath))
    
    # Significance (0/1)
    p = pheatmap::pheatmap(significant_matrix |> as.matrix(), treeheight_row = 0, treeheight_col = 0, 
                           color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100), 
                           show_rownames = FALSE, show_colnames = FALSE)
    ggsave(plot = p, filename = sprintf('%s/significance.pdf', save_plots_filepath))
  }
  
  
  

  matrices = list(foldchange = foldchange_matrix,
                  estimates = estimates_matrix,
                  se = se_matrix,
                  tstat = tstat_matrix,
                  significance = significant_matrix)
  return(matrices)
}



effects_df = effects_list$sceptre$all  |> filter(test == 'discovery') 

# effects_df = effects_df |> filter((gene %in% (topgenes |> arrange(desc(sum_tstats)) |> head(2000) |> pull(gene)))
#                                   & 
#                                   (grna %in% (topgrnas |> arrange(desc(sum_tstats)) |> head(50) |> pull(grna))))
# 
# matrices = make_matrices(effects_df = effects_df, save_plots_filepath = '../plots/matrix/toptstat/')


effects_df = effects_df |> filter((gene %in% (topgenes |> arrange(desc(score)) |> head(2000) |> pull(gene)))
                                  & 
                                  (grna %in% (topgrnas |> arrange(desc(score)) |> head(50) |> pull(grna))))

matrices = make_matrices(effects_df = effects_df, save_plots_filepath = '../plots/matrix/topscore/')
```




# Functions

## Low rank and sparse SVD Decomp + Plotting

```{r}


#' Get an approximation of the given matrix (mat) with the given ranks (ranks)
#' Can be a low rank matrix (SVD) or a sparse low rank matrix (sparse SVD (PMA::PMD))
#' @param mat (matrix) matrix to approximate
#' @param method (character) method for approximating the matrix
#'         either 'lowrank' or 'sparseSVD' 
#' @param ranks (vector) of positive integers indicating the ranks
#' @param save_plots_filepath (string) or NULL for no plots
#' @param color_limits (vector) of length 2, for the limits of the colors 
#'     default = c(-2, 2), try to use integers... it looks ugly ow
#' @param methodParams (list) of other parameters used in the approximation method
#' @example
#' lowrankmatrices = approx_lowrank(
#'        mat = matrices$estimates,
#'        ranks = c(1, 3, 5, 10, 15),
#'        save_plots_filepath = '../plots/matrix/lowrank/estimate/',
#'        color_limits = c(-2, 2)
#' )
approx_matrix <- function(mat, method, ranks, save_plots_filepath=NULL, color_limits = c(-2, 2), methodParams=NULL) {
  
  
  # mat = matrices$estimates|> as.matrix() 
  # mat |> as.matrix() |> as.vector() |> hist() # <- set limits to -2, 2
  # method = 'sparseSVD'
  # ranks = c(1, 3, 5, 10, 20)
  # save_plots_filepath = "../plots/matrix/sparseSVD/"
  # color_limits = c(-2, 2)
  # methodParams = list(type = 'standard', 
  #                     sumabs = .2, 
  #                     # sumabsu = 4, sumabsv = 4,
  #                     niter = 50,
  #                     trace = FALSE)
  
  
  
  # create some objects used for plotting later
  # - get a row and col order using clustering (marginally), for plotting later
  # - tall version of mat matrix
  if(!is.null(save_plots_filepath)) {
    matscaled = as.matrix(scale(mat))
    matscaled[is.nan(matscaled)] = 0
    row_order = hclust(dist(matscaled))$order
    column_order = hclust(dist(t(matscaled)))$order
    
    
    grna_index = data.frame(grna = rownames(mat)[row_order],
                            grna_idx  = 1:nrow(mat))
    gene_index = data.frame(gene = colnames(mat)[column_order],
                            gene_idx  = 1:ncol(mat))
    
    rm(matscaled, row_order, column_order)
    
      
    mat_tall = mat |> as.data.frame() |> tibble::rownames_to_column('grna') |> 
        tidyr::pivot_longer(cols = 2:(ncol(mat)+1), 
                            names_to = 'gene', values_to = 'value') |>
        mutate(group = 'original')
    
    
    mat_tall = merge(gene_index, mat_tall, by = 'gene')
    mat_tall = merge(grna_index, mat_tall, by = 'grna')
    
    plot_df_all = mat_tall
    
    # color breaks for plotting
    color_breaks = sort(union(color_limits, seq(from = round(color_limits[1]), to = round(color_limits[2]))))
    color_breaks_label = color_breaks
    color_breaks_label[which.min(color_breaks)] = sprintf('<%.1f', min(color_breaks))
    color_breaks_label[which.max(color_breaks)] = sprintf('>%.1f', max(color_breaks))
  }
  
  
  if(method == 'lowrank') {
    # low rank approximation ---------------------------
    svd_res = svd(x = mat, nu = max(ranks), nv = max(ranks))
    u = svd_res$u
    d = svd_res$d
    v = svd_res$v
    
    rm(svd_res)
  } else if(method == 'sparseSVD') {
    pmd_res = do.call(PMA::PMD,c(list(x=as.matrix(mat), K =  max(ranks)), methodParams)) 
    
    u = pmd_res$u
    d = pmd_res$d
    v = pmd_res$v
    
    rm(pmd_res)
  } else {
    return('Bad Method Input')
  }
  
    
  if(!is.null(save_plots_filepath)) { # plot the singular values
    # svd_res$d |> plot()
    ggplot(NULL, aes(x = 1:length(d),
               y = d)) +
      geom_point() +
      labs(x = 'singular value #', y = 'singular value', 
           title = 'Singular Values') +
      theme_bw() +
      theme(panel.grid.minor = element_blank())
    ggsave(sprintf('%s/singularvalues.pdf', save_plots_filepath), height = 4, width = 6)
    
  }
  

  
  
  # rank = r <= max(ranks)
  approxmatrices = list()
  for(r in ranks) { # there is a faster ay by adding the ne eigenvecs to prev...but it is ok
    # approximation should be U D V^T
    if(r == 1) { # r drops the vector/matrix form...
      diag_singvals = matrix(d[1], nrow=1, ncol=1)   
    } else {
      diag_singvals = diag(d[1:r]) 
    }
    
    approx = u[, 1:r, drop=FALSE] %*% diag_singvals %*% t(v[, 1:r, drop=FALSE])
    colnames(approx) = colnames(mat)
    rownames(approx) = rownames(mat)
    
    approxmatrices[[r]] = approx
    
    # plot original vs approx (side by side)? or just the approx? i think just 1 at a time
    if(!is.null(save_plots_filepath)) {
      # create df for plotting 
      plot_df = approx |> as.data.frame() |> tibble::rownames_to_column('grna') |> 
            tidyr::pivot_longer(cols = 2:(ncol(approx)+1), 
                               names_to = 'gene', values_to = 'value') |>
            mutate(group = sprintf('rank=%02d', r))
      plot_df = merge(gene_index, plot_df, by = 'gene')
      plot_df = merge(grna_index, plot_df, by = 'grna')
      
      # one plot at a time
      ggplot(plot_df) +
        geom_raster(aes(x = grna_idx, y = gene_idx, fill = value)) +
        scale_x_continuous(expand = c(0, 0)) +
        scale_y_continuous(expand = c(0, 0)) +
        labs(x='grna', y = 'gene', fill = NULL) +
        scale_fill_gradient2(limits = color_limits, # set color limits
                             oob=scales::squish, # if outside lims, set to limits
                             midpoint = 0, 
                             high = myRed, low = myBlue, mid = 'white',
                             breaks = color_breaks,
                             labels = color_breaks_label) +
        facet_wrap(vars(group), nrow=1) +
        theme_bw() +
        theme(strip.background = element_rect(fill = 'white'), 
              axis.ticks = element_blank(), 
              axis.text = element_blank(), 
              legend.position = 'bottom',
              legend.key.height = unit(.3, 'cm'),
              legend.key.width  = unit(1, 'cm'),
              legend.text = element_text(size = 7))
      
      ggsave(sprintf('%s/rank=%02d.pdf', save_plots_filepath, r), height = 6, width = 3)
      
      
      plot_df_all = rbind(plot_df_all, plot_df)
      
      
    }
  }
  
  
  # plot original and all lowrank approximations side by side
  if(!is.null(save_plots_filepath)) {
    
    plot_df_all$group = factor(
       plot_df_all$group, 
       levels = c('original', sprintf('rank=%02d', sort(ranks, decreasing=TRUE)))
    )
    
    
    
    ggplot(plot_df_all) +
      geom_raster(aes(x = grna_idx, y = gene_idx, fill = value)) +
      scale_x_continuous(expand = c(0, 0)) +
      scale_y_continuous(expand = c(0, 0)) +
      labs(x='grna', y = 'gene', fill = NULL) +
      scale_fill_gradient2(limits = color_limits, # set color limits
                           oob=scales::squish, # if outside lims, set to limits
                           midpoint = 0,
                           high = myRed, low = myBlue, mid = 'white',
                           # low  = brewer.pal(n = 9, name = "RdBu")[9],
                           # high = brewer.pal(n = 9, name = "RdBu")[1],
                           breaks = color_breaks,
                           labels = color_breaks_label) +
      facet_wrap(vars(group), nrow=1) +
      theme_bw() +
      theme(strip.background = element_rect(fill = 'white'), 
            panel.spacing = unit(.2, 'lines'),
            axis.ticks = element_blank(), 
            axis.text = element_blank(), 
            legend.position = 'bottom', 
            # legend.key.size = unit(.5, 'cm'),
            legend.key.height = unit(.3, 'cm'),
            legend.key.width  = unit(1.75, 'cm'),
            legend.text = element_text(size = 7))
    
    ggsave(sprintf('%s/rankall.pdf', save_plots_filepath), height = 6, width = 1.5*(length(ranks) + 1))
    
    
    # return the plot_df_all if it is created... (e.g. if the save plot file path is not NULL)
    # (want to return bc it is useful for shrinkage fn... should prob just make a function for
    #  matrix --> dataframe...)
    return(list(approxmatrices =approxmatrices,
                approxdf=plot_df_all))
  }

  

  
  return(list(approxmatrices=approxmatrices))
 
}



```


## Plotting Function
```{r}

#' @param mat (matrix) to plot
#' @param row_order (vector) of integers 
#'    c(4, 2, 8) indicates 1st row is rowidx=4
#' @param column_order (vector) of integers
plot_matrix <- function(mat, row_order=NULL, column_order=NULL, color_limits = c(-2, 2)) {
    # plot using the given row and col ordering
    if(!is.null(row_order) & !is.null(column_order)) {
        grna_index = data.frame(grna = rownames(mat)[row_order],
                                grna_idx  = 1:nrow(mat))
        gene_index = data.frame(gene = colnames(mat)[column_order],
                                gene_idx  = 1:ncol(mat))
    } else { # plot matrix as is
        grna_index = data.frame(grna = rownames(mat),
                                grna_idx  = 1:nrow(mat))
        gene_index = data.frame(gene = colnames(mat),
                                gene_idx  = 1:ncol(mat))
    }
  
    # color breaks for plotting
    color_breaks = sort(union(color_limits, seq(from = round(color_limits[1]), to = round(color_limits[2]))))
    color_breaks_label = color_breaks
    color_breaks_label[which.min(color_breaks)] = sprintf('<%.1f', min(color_breaks))
    color_breaks_label[which.max(color_breaks)] = sprintf('>%.1f', max(color_breaks))
     
    # create df for plotting 
    plot_df = mat |> as.data.frame() |> tibble::rownames_to_column('grna') |> 
          tidyr::pivot_longer(cols = 2:(ncol(mat)+1), 
                             names_to = 'gene', values_to = 'value')
    plot_df = merge(gene_index, plot_df, by = 'gene')
    plot_df = merge(grna_index, plot_df, by = 'grna')
    
    # plot matrix
    ggplot(plot_df) +
      geom_raster(aes(x = grna_idx, y = gene_idx, fill = value)) +
      scale_x_continuous(expand = c(0, 0)) +
      scale_y_continuous(expand = c(0, 0)) +
      labs(x='grna', y = 'gene', fill = NULL) +
      scale_fill_gradient2(limits = color_limits, # set color limits
                           oob=scales::squish, # if outside lims, set to limits
                           midpoint = 0, 
                           high = myRed, low = myBlue, mid = 'white',
                           breaks = color_breaks,
                           labels = color_breaks_label) +
      theme_bw() +
      theme(strip.background = element_rect(fill = 'white'), 
            axis.ticks = element_blank(), 
            axis.text = element_blank(), 
            legend.position = 'bottom',
            legend.key.height = unit(.3, 'cm'),
            legend.key.width  = unit(1, 'cm'),
            legend.text = element_text(size = 7))
}

```




# Structure in genes...

```{r}
# clearyrds = readRDS('../../../genData/cleary/GSM6858447_KO_conventional.rds')
# 
# 
# dim(clearyrds[['RNA']]$counts) # 16952 genes x 86956 cells
# 
# library(Matrix)
# 
# # counts = clearyrds[['RNA']]$counts[topgenes$gene[1:1000], ] |> t()
# counts = clearyrds[['RNA']]$counts[gene_dev_df |> arrange(desc(deviance)) |> head(1000) |> pull(gene_name), ] |> t()
# counts_cor = cor(as.matrix(counts), method = 'spearman')
# 
# heatmap(counts_cor, scale="none")
# 
# row_order = hclust(-counts_cor)$order
# heatmap(counts_cor[row_order, row_order], Colv=NA, Rowv=NA, scale="none")


```






# SVD: Shrink to a Low Rank Matrix









```{r}
# dir.create('../plots/matrix/lowrank/')
# dir.create('../plots/matrix/lowrank/estimate/')
# dir.create('../plots/matrix/lowrank/tstat/')
# dir.create('../plots/matrix/lowrank/significance/')
# dir.create('../plots/matrix/lowrank/foldchange/')
# dir.create('../plots/matrix/lowrank/se/')



lowrank_estimate = approx_matrix(mat = matrices$estimates,
                           method = 'lowrank', 
                                 ranks = c(1, 3, 5, 10, 15, 30),
                                 save_plots_filepath = '../plots/matrix/lowrank/estimate/',
                                 color_limits = c(-2, 2)) # matrices$estimates |> as.matrix() |> as.vector() |> hist()

lowrank_tstat = approx_matrix(mat = matrices$tstat,
                           method = 'lowrank', 
                                 ranks = c(1, 3, 5, 10, 15, 30),
                                 save_plots_filepath = '../plots/matrix/lowrank/tstat/',
                                 color_limits = c(-4, 4)) # matrices$tstat |> as.matrix() |> as.vector() |> hist()

lowrankres = approx_matrix(mat = matrices$significance,
                           method = 'lowrank', 
                                 ranks = c(1, 3, 5, 10, 15, 30),
                                 save_plots_filepath = '../plots/matrix/lowrank/significance/',
                                 color_limits = c(-1, 1))

lowrankres = approx_matrix(mat = matrices$foldchange,
                           method = 'lowrank', 
                                 ranks = c(1, 3, 5, 10, 15, 30),
                                 save_plots_filepath = '../plots/matrix/lowrank/foldchange/',
                                 color_limits = c(0, 2)) # matrices$foldchange |> as.matrix() |> as.vector() |> hist()
 
lowrankres = approx_matrix(mat = matrices$se,
                           method = 'lowrank', 
                                 ranks = c(1, 3, 5, 10, 15, 30),
                                 save_plots_filepath = '../plots/matrix/lowrank/se/',
                                 color_limits = c(0, 3)) # matrices$se |> as.matrix() |> as.vector() |> hist()
rm(lowrankres)
 
```



# Sparse SVD: Shrink to a Sparse Low Rank Matrix


```{r}

# dir.create('../plots/matrix/sparseSVD/')
# dir.create('../plots/matrix/sparseSVD/estimate/')
# dir.create('../plots/matrix/sparseSVD/tstat/')
# dir.create('../plots/matrix/sparseSVD/significance/')
# dir.create('../plots/matrix/sparseSVD/foldchange/')
# dir.create('../plots/matrix/sparseSVD/se/')

sparseSVD_estimate = approx_matrix(mat = matrices$estimates, 
              method = 'sparseSVD', 
              ranks = c(1, 3, 5, 10, 15, 30),
              save_plots_filepath="../plots/matrix/sparseSVD/estimate/", 
              color_limits = c(-2, 2), 
              methodParams=list(type = 'standard', 
                                sumabs = .35,  # should be between 0-1, 
                                # sumabsu = 4, sumabsv = 4, # between 1 and sqrt(#col or #rows)
                                niter = 100,
                                trace = FALSE)) 
  
  
sparseSVD_tstat = approx_matrix(mat = matrices$tstat, 
              method = 'sparseSVD', 
              ranks = c(1, 3, 5, 10, 15, 30),
              save_plots_filepath="../plots/matrix/sparseSVD/tstat/", 
              color_limits = c(-4, 4), 
              methodParams=list(type = 'standard', 
                                sumabs = .35,  # should be between 0-1, 
                                # sumabsu = 4, sumabsv = 4, # between 1 and sqrt(#col or #rows)
                                niter = 100,
                                trace = FALSE)) 




```




# Biclustering: shrink to what?



```{r}

plot_matrix(mat = matrices$estimate, color_limits = c(-2, 2)) 
plot_matrix(mat = matrices$tstat, color_limits = c(-4, 4)) 

```




```{r}

library(biclust)



dim(sparseSVD_tstat$approxmatrices[[10]])
# trying biclustering algs (default args)
bicl_res = biclust::biclust(matrices$tstat |> as.matrix(), method=BCSpectral() , 
                            normalization="bistochastization", numberOfEigenvalues=6)

bicl_res = biclust::biclust(matrices$tstat |> as.matrix(), method=BCCC(), 
                            delta = 1.0, alpha=1.5, number=100)



bicl_res = biclust::biclust(sparseSVD_tstat$approxmatrices[[15]], method=BCCC(), 
                            delta = 1, alpha=1.5, number=100)


bicl_res = biclust::biclust(lowrank_estimate$approxmatrices[[15]], method= BCQuest())




bicl_res@Parameters
bicl_res@RowxNumber
bicl_res@NumberxCol

test <- matrix(rnorm(5000),100,50)
test[11:20,11:20] <- rnorm(100,10,0.1)
image(test)
shuffled_test <- test[sample(nrow(test)), sample(ncol(test))]
image(shuffled_test)
res1 <- spectral(shuffled_test,normalization="log", numberOfEigenvalues=6,
                 minr=2, minc=2, withinVar=1, n_clusters = NULL, n_best = 3)
data.frame(a = res1@RowxNumber)



apply(X = res1@RowxNumber, MARGIN = 1, FUN = which, simplify = TRUE)

apply(X = res1@NumberxCol, MARGIN = 2, FUN = which, simplify = TRUE) |> unlist()



install.packages('s4vd')
library(s4vd)
```





# Actually Shrinking...







```{r}


# need: 
# - original unshrunk point
# - shrinkage point
# - se

#' Shrink unshrunk matrix to shrinkage point matrix using ebci method 
#' se mat should have the unshrunk matrix estimates' se
#' @param unshrunk_mat (matrix) of unshrunk estimates
#' @param shrinkpoint_mat (matrix) of points to shrink to (e.g. lower dim mat)
#' @param se_mat (matrix) of standard errors for unshrunk matrices' estimates
#' @param ALPHA (numeric) in [0,1] test level for constructing ebci CI's
#' @output dataframe of shrinkage results with at least the following columns
#' "grna"            "gene"            "unshrunk_value"  "shrinkage_point" "se"
#' "shrunk_value"    "lower_ci"        "upper_ci" 
#' @example 
#'  shrink_matrix(   unshrunk_mat = matrices$estimates,
#'              shrinkpoint_mat = sparseSVD_estimate$approxmatrices[[15]],
#'                       se_mat = se_mat,
#'              ALPHA = .1) # ~15 mins for 50x2000 
shrink_matrix <- function(unshrunk_mat,
                          shrinkpoint_mat,
                          se_mat,
                          ALPHA) {
  
  
  unshrunk       = unshrunk_mat|> as.data.frame() |> 
                   tibble::rownames_to_column('grna') |>
                   tidyr::pivot_longer(cols = 2:(ncol(unshrunk_mat)+1),
                                       names_to = 'gene', values_to = 'unshrunk_value')
  
  
  shrinkagepoint = shrinkpoint_mat |> as.data.frame() |>
                   tibble::rownames_to_column('grna') |>
                   tidyr::pivot_longer(cols = 2:(ncol(shrinkpoint_mat)+1),
                                       names_to = 'gene', values_to = 'shrinkage_point')
  
  se             = se_mat |> as.data.frame() |> 
                   tibble::rownames_to_column('grna') |> 
                   tidyr::pivot_longer(cols = 2:(ncol(se_mat)+1), 
                                       names_to = 'gene', values_to = 'se')
  
  
  ebci_data = merge(merge(unshrunk, shrinkagepoint, 
                          by = c('grna', 'gene')),
                    se, by = c('grna', 'gene'))
  
  
  
  # t0 = Sys.time()
  ebci_obj = ebci::ebci(formula = sprintf('%s - shrinkage_point ~ 0', 'unshrunk_value'),
                    # formula = 'tstat - shrinkage_point ~ 0', # ebci_formula
                    data    = ebci_data, 
                    # se = eval(parse(text = se_colname)), 
                    # weights =  eval(parse(text = sprintf('1/%s^2', se_colname))), 
                    se = se,
                    # weights = 1/nrow(ebci_data),
                    alpha = ALPHA)
  # t1 = Sys.time(); print(t1 - t0)
  
  ebci_res = ebci_data |> 
             # head(nrow(ebci_obj$df)) |>
             dplyr::mutate(shrunk_value = ebci_obj$df$th_eb + shrinkage_point,
                           lower_ci = shrunk_value - ebci_obj$df$len_eb,
                           upper_ci = shrunk_value + ebci_obj$df$len_eb)
  return(ebci_res)
}


#' @param df (dataframe) of ebci results, should have the following columns:
#' "grna"            "gene"            "unshrunk_value"  "shrinkage_point" "se"
#' "shrunk_value"    "lower_ci"        "upper_ci" 
#' @output list of plots. you can plot them all together with 
#'         gridExtra::grid.arrange(grobs = somePlots)
shrink_matrix_plots <- function(df) {
  
  plots = list()
  
  plots$se_hist = ggplot(df, aes(x = se)) + geom_histogram() + theme_classic()
  
  plots$shrinkagepoint_hist = ggplot(df, aes(x = shrinkage_point)) + geom_histogram() + theme_classic()

  
  # plot shrunk vs unshrunk
  plots$shrunk_unshrunk_point = 
    ggplot(df) +
      geom_abline(aes(slope = 1, intercept = 0), color = 'gray') +
      geom_point(aes(x = unshrunk_value, y = shrunk_value, color = se)) +
      theme_classic()
  
  # plot shrunk vs unshrunk centered
  plots$shrunk_unshrunk_centered_point = 
    ggplot(df) +
      geom_abline(aes(slope = 1, intercept = 0), color = 'gray') +
      geom_point(aes(x = unshrunk_value - shrinkage_point, y = shrunk_value - shrinkage_point, color = se)) +
      theme_classic()
  
  # plot unshrunk vs shrinkage point
  plots$unshrunk_shrinkagepoint_point =
    ggplot(df) +
      geom_abline(aes(slope = 1, intercept = 0), color = 'gray') +
      geom_point(aes(x = unshrunk_value, y = shrinkage_point, color = se)) +
      theme_classic()
  
  return(plots)

}



effects_df = effects_df |> filter((gene %in% (topgenes |> arrange(desc(score)) |> head(2000) |> pull(gene)))
                                  & 
                                  (grna %in% (topgrnas |> arrange(desc(score)) |> head(50) |> pull(grna))))

matrices = make_matrices(effects_df = effects_df, save_plots_filepath = '../plots/matrix/topscore/')


# running using function
sparseSVD_estimate = approx_matrix(mat = matrices$estimates, 
              method = 'sparseSVD', 
              ranks = c(15),
              # save_plots_filepath="../plots/matrix/sparseSVD/estimate/", 
              color_limits = c(-2, 2), 
              methodParams=list(type = 'standard', 
                                sumabs = .35,  # should be between 0-1, 
                                # sumabsu = 4, sumabsv = 4, # between 1 and sqrt(#col or #rows)
                                niter = 100,
                                trace = FALSE))

# max se set to more reasonable value ... idk hy this takes long...
se_mat = apply(X = matrices$se, MARGIN=2, function(x){pmin(x, quantile(matrices$se |> unlist(), .91))})


shrinkEstSparse15 = 
  shrink_matrix(   unshrunk_mat = matrices$estimates,
              shrinkpoint_mat = sparseSVD_estimate$approxmatrices[[15]],
                       se_mat = se_mat,
              ALPHA = .1) # ~15 mins

dim(shrinkEstSparse15)
head(shrinkEstSparse15)

somePlots = shrink_matrix_plots(df = shrinkEstSparse15)
gridExtra::grid.arrange(grobs = somePlots)






```



# Overall:

(put this into an r script probably)

```{r}
# === Settings/Parameters ===
ALPHA = .1

# approximations and shrinkage choices
PLOT_RANKS = c(1, 3, 5, 10, 15, 30)
APPROX_SHRINK_CHOICES = list('1' = list(approx='lowrank', rank= 5),
                             '2' = list(approx='lowrank', rank=10),
                             '3' = list(approx='lowrank', rank=15),
                             '4' = list(approx='lowrank', rank=30),
                             '5' = list(approx='sparseSVD', rank= 5),
                             '6' = list(approx='sparseSVD', rank=10),
                             '7' = list(approx='sparseSVD', rank=15),
                             '8' = list(approx='sparseSVD', rank=30))

APPROX_SHRINK_CHOICES = list('1' = list(approx='lowrank', rank= 5),
                             '7' = list(approx='sparseSVD', rank=15),
                             '8' = list(approx='sparseSVD', rank=30))



# === Load and Prep Data ===
## load
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(tidyr))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(RColorBrewer))
suppressPackageStartupMessages(library(ebci)) # robust emp shrinkage
suppressPackageStartupMessages(library(assertthat)) 


# source('../utils/myKmeans.R')
# source('../utils/cluster_and_ebci_shrinkage.r')
source('../utils/matrix_shrinkage.r')

dir.create('../saves/matrix/')
dir.create('../saves/matrix/shrinkMatrix/')

dir.create('../plots/matrix/')
dir.create('../plots/matrix/topGeneGrna/') # compare diff ways to rank top genes/grna
dir.create('../plots/matrix/topGeneGrna/topscore/')
dir.create('../plots/matrix/topGeneGrna/toptstat/')

dir.create('../plots/matrix/approxMatrix/') # diff ways to approximate matrix
dir.create('../plots/matrix/approxMatrix/lowrank/')
dir.create('../plots/matrix/approxMatrix/lowrank/estimate/')
dir.create('../plots/matrix/approxMatrix/lowrank/tstat/')
dir.create('../plots/matrix/approxMatrix/lowrank/significance/')
dir.create('../plots/matrix/approxMatrix/lowrank/foldchange/')
dir.create('../plots/matrix/approxMatrix/lowrank/se/')
dir.create('../plots/matrix/approxMatrix/sparseSVD/')
dir.create('../plots/matrix/approxMatrix/sparseSVD/estimate/')
dir.create('../plots/matrix/approxMatrix/sparseSVD/tstat/')
dir.create('../plots/matrix/approxMatrix/sparseSVD/significance/')
dir.create('../plots/matrix/approxMatrix/sparseSVD/foldchange/')
dir.create('../plots/matrix/approxMatrix/sparseSVD/se/')

dir.create('../plots/matrix/shrinkMatrix/') # shrinkage

# load estimated effects
effects_list = list()
for(est_method in c('sceptre')){ # , 'poisson', 'nb')) {
  effects_list[[est_method]] = list()
  for(testsplit in c('all')) {# c('train', 'test', 'all')) {
    
    if(est_method == 'sceptre') {path = 'sceptre/sceptre'} 
    else if(est_method == 'nb') {path = 'negativebinomial'}
    else {path = est_method}
    
    effects_list[[est_method]][[testsplit]] = 
      read.csv(sprintf('../saves/%s_effects_%s.csv',
                       path, testsplit)) |> 
      # filter(!is.na(estimate)) |>   # remove tests with NA estimates
      mutate(tstat = estimate / se) # make a tstat column = estimate / se
  }
}



# method_nice_names = list('sceptre'='SCEPTRE',
#                          'poisson'='Poisson',
#                          'nb'     ='Negative Binomial')


# effects_df = read.csv('../saves/sceptre/sceptre_effects_all.csv')

# topgenes = read.csv('../saves/sceptre/topgenes.csv')
# topgrnas = read.csv('../saves/sceptre/topgrnas.csv')

# gene_dev_df = read.csv('../saves/gene_deviance.csv') # df of gene importance (cols: idx, deviance, gene_name)


# my_positive_control_pairs = read.csv('../saves/sceptre/positive_control_pairs.csv')
# my_discovery_pairs = read.csv('../saves/sceptre/discovery_pairs.csv'       )

# select top genes and grna 
# effects_all_df = read.csv('../saves/sceptre/sceptre_effects_all.csv') 



## prep

### important genes and grnas selected by a 'score'
effects_df = effects_list[['sceptre']][['all']] |> filter(test == 'discovery') # | test == 'positive') 
topgenes = effects_df |> group_by(gene) |> summarize(sum_effects = sum(abs(estimate), na.rm = TRUE),
                                                      sd_effects = sd(estimate, na.rm = TRUE),
                                                     sig_effects = sum(significant, na.rm=TRUE),
                                                     sum_tstats  = sum(abs(estimate/se), na.rm = TRUE)) |>
                         mutate(score = scale(sum_effects) + (1/3)* scale(sd_effects) +  sig_effects) |> 
                         arrange(desc(score)) |> 
                         arrange(desc(sum_tstats))
topgrnas = effects_df |> group_by(grna) |> summarize(sum_effects = sum(abs(estimate), na.rm = TRUE),
                                                      sd_effects = sd(estimate, na.rm = TRUE),
                                                     sig_effects = sum(significant, na.rm=TRUE),
                                                     sum_tstats  = sum(abs(estimate/se), na.rm = TRUE)) |>
                         mutate(score = scale(sum_effects) + (0)* scale(sd_effects) +  sig_effects) |> 
                         arrange(desc(score)) |> 
                         arrange(desc(sum_tstats))

effects_df = effects_df |> filter((gene %in% (topgenes |> arrange(desc(score)) |> head(2000) |> pull(gene)))
                                  & 
                                  (grna %in% (topgrnas |> arrange(desc(score)) |> head(50) |> pull(grna))))


### Construct matrices of estimate and se (and others, but not used, plots some in the process)
# construct matrices (explore toptstat, but use topscore)
matrices = make_matrices(effects_df = effects_df  |> 
                           filter((gene %in% (topgenes |> arrange(desc(sum_tstats)) |> head(2000) |> pull(gene)))
                                  &
                                  (grna %in% (topgrnas |> arrange(desc(sum_tstats)) |> head(50) |> pull(grna)))), 
                         save_plots_filepath = '../plots/matrix/topGeneGrna/toptstat/')


matrices = make_matrices(effects_df = effects_df, save_plots_filepath = '../plots/matrix/topGeneGrna/topscore/')


# max se set to more reasonable value (not 999)... idk why this takes long...
se_mat = apply(X = matrices$se, MARGIN=2,
               FUN = function(x){pmin(x, quantile(matrices$se |> unlist(), .91))})


assertthat::assert_that(quantile(matrices$se |> unlist(), .91) < 999, 
                        msg = "Fix: set limit for se to be < 999 (e.g. set quantile smaller)")


# === Approximate Matrices and Shrink ===


## approximate matrices

# gather all ranks requested
allranks = c()
for(name in names(APPROX_SHRINK_CHOICES)) {
  allranks = c(allranks, APPROX_SHRINK_CHOICES[[name]]$rank)
}



# just for creating and saving plots
if(T) { # Also do for other values like tstat, se, etc...
  
  lowrankres = approx_matrix(mat = matrices$estimates,
                             method = 'lowrank', 
                                   ranks = PLOT_RANKS,
                                   save_plots_filepath = '../plots/matrix/approxMatrix/lowrank/estimate/',
                                   color_limits = c(-2, 2)) # matrices$estimates |> as.matrix() |> as.vector() |> hist()
  
  lowrankres = approx_matrix(mat = matrices$tstat,
                             method = 'lowrank', 
                                   ranks = PLOT_RANKS,
                                   save_plots_filepath = '../plots/matrix/approxMatrix/lowrank/tstat/',
                                   color_limits = c(-4, 4)) # matrices$tstat |> as.matrix() |> as.vector() |> hist()
  
  lowrankres = approx_matrix(mat = matrices$significance,
                             method = 'lowrank', 
                                   ranks = PLOT_RANKS,
                                   save_plots_filepath = '../plots/matrix/approxMatrix/lowrank/significance/',
                                   color_limits = c(-1, 1))
  
  lowrankres = approx_matrix(mat = matrices$foldchange,
                             method = 'lowrank', 
                                   ranks = PLOT_RANKS,
                                   save_plots_filepath = '../plots/matrix/approxMatrix/lowrank/foldchange/',
                                   color_limits = c(0, 2)) # matrices$foldchange |> as.matrix() |> as.vector() |> hist()
   
  lowrankres = approx_matrix(mat = matrices$se,
                             method = 'lowrank', 
                                   ranks = PLOT_RANKS,
                                   save_plots_filepath = '../plots/matrix/approxMatrix/lowrank/se/',
                                   color_limits = c(0, 3)) # matrices$se |> as.matrix() |> as.vector() |> hist()
  rm(lowrankres)
  
  sparsesvdres = approx_matrix(mat = matrices$estimates, 
          method = 'sparseSVD', 
          ranks = PLOT_RANKS,
          save_plots_filepath="../plots/matrix/approxMatrix/sparseSVD/estimate/", 
          color_limits = c(-2, 2), 
          methodParams=list(type = 'standard', 
                            sumabs = .35,  # should be between 0-1, 
                            # sumabsu = 4, sumabsv = 4, # between 1 and sqrt(#col or #rows)
                            niter = 100,
                            trace = FALSE)) 
  
  sparsesvdres = approx_matrix(mat = matrices$tstat, 
              method = 'sparseSVD', 
              ranks = PLOT_RANKS,
              save_plots_filepath="../plots/matrix/approxMatrix/sparseSVD/tstat/", 
              color_limits = c(-4, 4), 
              methodParams=list(type = 'standard', 
                                sumabs = .35,  # should be between 0-1, 
                                # sumabsu = 4, sumabsv = 4, # between 1 and sqrt(#col or #rows)
                                niter = 100,
                                trace = FALSE))
  
  sparsesvdres = approx_matrix(mat = matrices$foldchange, 
              method = 'sparseSVD', 
              ranks = PLOT_RANKS,
              save_plots_filepath="../plots/matrix/approxMatrix/sparseSVD/foldchange/", 
              color_limits = c(-4, 4), 
              methodParams=list(type = 'standard', 
                                sumabs = .35,  # should be between 0-1, 
                                # sumabsu = 4, sumabsv = 4, # between 1 and sqrt(#col or #rows)
                                niter = 100,
                                trace = FALSE))
  rm(sparsesvdres)
 
}

# approximate matrices for shrinkage
approxmatrices = list()

approxmatrices$lowrank = 
  approx_matrix(mat = matrices$estimates, 
          method = 'lowrank', 
          ranks = allranks) 

approxmatrices$sparseSVD = 
  approx_matrix(mat = matrices$estimates, 
          method = 'sparseSVD', 
          ranks = allranks,
          methodParams=list(type = 'standard', 
                            sumabs = .35,  # should be between 0-1, 
                            # sumabsu = 4, sumabsv = 4, # between 1 and sqrt(#col or #rows)
                            niter = 100,
                            trace = FALSE)) 
  

## perform ebci shrinkage to approx matrix point
for(name in names((APPROX_SHRINK_CHOICES))) {
  approxMethod = APPROX_SHRINK_CHOICES[[name]]$approx
  rank         = APPROX_SHRINK_CHOICES[[name]]$rank
  
  
  
  shrinkDF = 
    shrink_matrix(   unshrunk_mat = matrices$estimates,
                shrinkpoint_mat = approxmatrices[[approxMethod]]$approxmatrices[[rank]],
                         se_mat = se_mat,
                ALPHA = ALPHA) # ~15 mins
  
  
  
  shrinkDFPlots = shrink_matrix_plots(df = shrinkDF)
  
  pdf(sprintf("../plots/matrix/shrinkMatrix/shrinkMatrix_%s_r=%02.f.pdf",approxMethod, rank))
  gridExtra::grid.arrange(grobs = shrinkDFPlots)
  dev.off()
  
  write.csv(x = shrinkDF,
            file = sprintf("../saves/matrix/shrinkMatrix/shrinkMatrix_%s_r=%02.f.csv",approxMethod, rank))

}













```


























































# Trash (Extra Code)


## Selecting and Plotting effects


```{r echo=FALSE, eval=FALSE, include=FALSE}
# select top genes and grna 
effects_all_df = read.csv('../saves/sceptre/sceptre_effects_all.csv') 
effects_df = effects_all_df |> filter(test == 'discovery') # | test == 'positive') 
topgenes = effects_df |> group_by(gene) |> summarize(sum_effects = sum(abs(estimate), na.rm = TRUE),
                                                      sd_effects = sd(estimate, na.rm = TRUE),
                                                     sig_effects = sum(significant, na.rm=TRUE),
                                                     sum_tstats  = sum(abs(estimate/se), na.rm = TRUE)) |>
                         mutate(score = scale(sum_effects) + (1/3)* scale(sd_effects) +  sig_effects) |> arrange(desc(score)) |> arrange(desc(sum_tstats))
topgrnas = effects_df |> group_by(grna) |> summarize(sum_effects = sum(abs(estimate), na.rm = TRUE),
                                                      sd_effects = sd(estimate, na.rm = TRUE),
                                                     sig_effects = sum(significant, na.rm=TRUE),
                                                     sum_tstats  = sum(abs(estimate/se), na.rm = TRUE)) |>
                         mutate(score = scale(sum_effects) + (0)* scale(sd_effects) +  sig_effects) |> arrange(desc(score)) |> arrange(desc(sum_tstats))



plot(topgenes |> arrange(desc(score)) |> pull(sig_effects))
plot(topgenes |> arrange(desc(score)) |> pull(sum_effects) |> scale())
plot(topgenes |> arrange(desc(score)) |> pull(sd_effects) |> scale())

cor(topgenes$sum_effects, topgenes$sd_effects)
topgenes[is.na( topgenes$sd_effects), ]
effects_df |> filter(gene == 'MAP2K6')
effects_df$n_nonzero_trt |> hist()
effects_df$n_nonzero_cntrl |> hist()

plot(topgenes$sum_effects, type = 'l')
plot(topgrnas$sum_effects, type = 'l')
```


```{r echo=FALSE, eval=FALSE, include=FALSE}

topgenes$gene[1:100]
genes_ranks = merge(topgenes |> mutate(effects_rank = 1:n()),
                    gene_dev_df |> rename(gene = gene_name) |> dplyr::select(-idx) |> arrange(desc(deviance)) |> mutate(dev_rank = 1:n()), 
                    by = 'gene')  |> arrange(dev_rank)

cor(genes_ranks$effects_rank, genes_ranks$dev_rank) #/ negative????? very lowly correlated?? high dev overall indicates high effect sizes
genes_ranks |> filter(effects_rank < 100) |> arrange(effects_rank) # however, there are many genes with large effect sizes
effects_df |> filter(gene == 'C1orf198')


effects_df |> filter(gene == 'C1orf198' & test == 'discovery') |> pull(estimate) |> abs() |> sum(na.rm=TRUE)
topgenes |> arrange(desc(sum_effects))
topgenes |> mutate(dev_rank = 1) |> filter(gene == 'C1orf198')
gene_dev_df |> select(-idx) |> arrange(desc(deviance)) |> mutate(dev_rank = 1:n()) |> filter(gene_name == 'C1orf198')

my_discovery_pairs |> filter(response_id == 'C1orf198')
my_positive_control_pairs |> filter(response_id == 'C1orf198')


my_discovery_pairs |> filter(response_id == 'TGIF1')
my_positive_control_pairs |> filter(response_id == 'TGIF1')


genes_ranks |> filter(dev_rank > 10000 & !(gene %in% my_positive_control_pairs$response_id)) # should be nothing... the only genes with smaller dev are those chosen bc they are the target of a grna

```





```{r echo=FALSE, eval=FALSE, include=FALSE}
names(effects_list)
names(effects_list$sceptre)


# testing code for turning into matrix and then taking low rank/sparse form

effects_df = effects_list$sceptre$all
# effects_df = effects_list$nb$train

effects_df = effects_df |> filter(test == 'discovery') 
effects_df = effects_df |> filter((gene %in% topgenes$gene[1:200]) & (grna %in% topgrnas$grna[1:100]))

# effects_list$sceptre$train$gene |> unique() |> length()
# effects_df$gene |> unique() |> length()
# 
# effects_df |> filter(test == 'discovery') |> group_by(grna) |> summarize(count = n())

gene_index = data.frame(gene = sort(unique(effects_df$gene))) |>
             mutate(gene_idx = 1:n())
grna_index = data.frame(grna = sort(unique(effects_df$grna))) |>
             mutate(grna_idx = 1:n())

effects_df = merge(gene_index, effects_df, by = 'gene')
effects_df = merge(grna_index, effects_df, by = 'grna')

# effects_df |> group_by(grna, gene) |> summarize(count = n()) |> filter(count > 1)
# effects_df |> filter(grna == 'CASP8' & gene == 'CASP8')
# effects_df |> filter(grna_idx %in% 1:4)
# effects_df |> filter(gene_idx %in% 1:4)
# 
# effects_df |> filter(grna_idx %in% 1:10 & gene_idx %in% 1:10) |> 
#   select(grna, gene, estimate) |>
#   tidyr::pivot_wider(names_from = gene, values_from = estimate)

ggplot(effects_df) +
  geom_raster(aes(x = grna_idx, y = gene_idx, fill = estimate)) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_fill_gradient2() +
  theme_classic() 



# Some tests missing bc failed quality check (from sceptre)
# fill estimate = 0, and se = 999 (for now)
foldchange_matrix = effects_df |> # filter(grna_idx %in% 1:400 & gene_idx %in% 1:400) |> 
  dplyr::select(grna, gene, fold_change) |>
  tidyr::pivot_wider(names_from = gene, values_from = fold_change) |>
  tibble::column_to_rownames(var='grna')
foldchange_matrix[is.na(foldchange_matrix)] = 0

# fill estimate = 0, and se = 999 (for now)
estimates_matrix = effects_df |> # filter(grna_idx %in% 1:400 & gene_idx %in% 1:400) |> 
  dplyr::select(grna, gene, estimate) |>
  tidyr::pivot_wider(names_from = gene, values_from = estimate) |>
  tibble::column_to_rownames(var='grna')
estimates_matrix[is.na(estimates_matrix)] = 0

se_matrix = effects_df |> # filter(grna_idx %in% 1:400 & gene_idx %in% 1:400) |> 
  dplyr::select(grna, gene, se) |>
  tidyr::pivot_wider(names_from = gene, values_from = se) |>
  tibble::column_to_rownames(var='grna')
se_matrix[is.na(se_matrix)] = 999

tstat_matrix = effects_df |> # filter(grna_idx %in% 1:400 & gene_idx %in% 1:400) |> 
  dplyr::select(grna, gene, tstat) |>
  tidyr::pivot_wider(names_from = gene, values_from = tstat) |>
  tibble::column_to_rownames(var='grna')
tstat_matrix[is.na(tstat_matrix) ] = 0 # fill NA (from se) to 0 (e.g. not significant)

significant_matrix = effects_df |>
  dplyr::select(grna, gene, significant) |>
  tidyr::pivot_wider(names_from = gene, values_from = significant) |>
  tibble::column_to_rownames(var='grna')
significant_matrix[is.na(significant_matrix) ] = 0 # fill NA (from se) to 0 (e.g. not significant)



# vis
library(RColorBrewer)
pheatmap::pheatmap(foldchange_matrix |> as.matrix(), treeheight_row = 0, treeheight_col = 0, 
                   color = colorRampPalette((brewer.pal(n = 7, name = "YlOrRd")))(100))

pheatmap::pheatmap(estimates_matrix |> as.matrix(), treeheight_row = 0, treeheight_col = 0, 
                   color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100))
heatmap(estimates_matrix |> as.matrix())



pheatmap::pheatmap(tstat_matrix |> as.matrix(), treeheight_row = 0, treeheight_col = 0, 
                   show_rownames = FALSE, show_colnames = FALSE)
heatmap(tstat_matrix |> as.matrix())


pheatmap::pheatmap(significant_matrix |> as.matrix(), treeheight_row = 0, treeheight_col = 0, 
                   show_rownames = FALSE, show_colnames = FALSE)
heatmap(significant_matrix |> as.matrix())


estimates_matrix |> tidyr::pivot_longer(cols = 2:ncol(estimates_matrix), 
                                        names_to = 'gene', values_to = 'estimate')







# low rank
svd_res = svd(x = estimates_matrix, nu = 5, nv = 5)
svd_res$d |> plot()
# approximation should be U D V^T
lowrank = svd_res$u %*% diag(svd_res$d[1:5]) %*% t(svd_res$v)

colnames(lowrank) = colnames(estimates_matrix)
rownames(lowrank) = rownames(estimates_matrix)

dim(estimates_matrix)
lowrank |> dim()
image(estimates_matrix |> as.matrix())
image(lowrank, useRaster = TRUE)


plot_df = rbind(
    estimates_matrix |> tibble::rownames_to_column('grna') |> 
      tidyr::pivot_longer(cols = 2:(ncol(estimates_matrix)+1), 
                        names_to = 'gene', values_to = 'estimate') |>
      mutate(group = '1 original')
    ,
    lowrank |> as.data.frame() |> tibble::rownames_to_column('grna') |> 
      tidyr::pivot_longer(cols = 2:(ncol(lowrank)+1), 
                         names_to = 'gene', values_to = 'estimate') |>
      mutate(group = '2 lowrank')
    )
plot_df = merge(gene_index, plot_df, by = 'gene')
plot_df = merge(grna_index, plot_df, by = 'grna')

ggplot(plot_df) +
  geom_raster(aes(x = grna_idx, y = gene_idx, fill = estimate)) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_fill_gradient2() +
  facet_wrap(vars(group), nrow=1) +
  theme_bw() 



# mat = as.matrix(scale(estimates_matrix))
# mat[is.nan(mat)] = 0
# row_order = hclust(dist(mat))$order
# column_order = hclust(dist(t(mat)))$order
# heatmap(estimates_matrix[row_order,column_order] |> as.matrix(), Colv=NA, Rowv=NA, scale="none")
# heatmap(         lowrank[row_order,column_order] |> as.matrix(), Colv=NA, Rowv=NA, scale="none")
# 
# hist(c(estimates_matrix) |> unlist())
# hist(c(lowrank) |> unlist())

```



```{r}

set.seed(1)
m <- 1e4
n <- 1e3
k <- 3e2
X <- matrix(rnorm(m*k), nrow=m)
Y <- matrix(rnorm(n*k), ncol=n)

Z <- X %*% Y





# sparse decomposition? 

# install.packages('rsparse') # r package- use special installation steps for parallel/other things
library(rsparse)
# look at github: david-cortes/R-openblas-in-windows

# probably want truncated svd
rsparse::detect_number_omp_threads()
rsparse::soft_svd()

rsparse::soft_svd(Z)


# "Matrix Completion and Low-Rank SVD via Fast Alternating Least Squares" by Hastie et al., 2014.
# library(softImpute) #






# penalized matrix decomposition, Witten et al., 2009
library(PMA)

test = PMA::PMD(Z)

```
```{r echo=FALSE, eval=FALSE, include=FALSE}
positive_effects_df = effects_list$sceptre$all |> filter(test == 'positive') 

positive_effects_df$fold_change |> hist()

effects_df$fold_change |> hist()
pheatmap::pheatmap(estimates_matrix[1:5, ] |> as.matrix(), 
                   treeheight_row = 0, treeheight_col = 0, 
                   color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100), scale = 'none')
grna_effects_cor = cor(t(estimates_matrix))
dim(grna_effects_cor)
pheatmap::pheatmap(grna_effects_cor, treeheight_row = 0, treeheight_col = 0, 
                   color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100))


mat = as.matrix(scale(estimates_matrix))
mat[is.nan(mat)] = 0
row_order = hclust(dist(mat))$order
column_order = hclust(dist(t(mat)))$order

heatmap(estimates_matrix[row_order,column_order] |> as.matrix(), Colv=NA, Rowv=NA, scale="none")

heatmap(significant_matrix |> as.matrix())
```



```{r}

mat = matrices$estimates

# low rank
svd_res = svd(x = mat, nu = 10, nv = 10)
svd_res$d |> plot()
# approximation should be U D V^T
lowrank = svd_res$u %*% diag(svd_res$d[1:10]) %*% t(svd_res$v)

colnames(lowrank) = colnames(mat)
rownames(lowrank) = rownames(mat)

dim(mat)
lowrank |> dim()
image(estimates_matrix |> as.matrix())
image(lowrank, useRaster = TRUE)


plot_df = rbind(
    mat |> tibble::rownames_to_column('grna') |> 
      tidyr::pivot_longer(cols = 2:(ncol(mat)+1), 
                          names_to = 'gene', values_to = 'estimate') |>
      mutate(group = '1 original')
    ,
    lowrank |> as.data.frame() |> tibble::rownames_to_column('grna') |> 
      tidyr::pivot_longer(cols = 2:(ncol(lowrank)+1), 
                         names_to = 'gene', values_to = 'estimate') |>
      mutate(group = '2 lowrank')
    )


matscaled = as.matrix(scale(mat))
matscaled[is.nan(matscaled)] = 0
row_order = hclust(dist(matscaled))$order
column_order = hclust(dist(t(matscaled)))$order


grna_index = data.frame(grna = rownames(mat)[row_order],
                        grna_idx  = 1:nrow(mat))
gene_index = data.frame(gene = colnames(mat)[column_order],
                        gene_idx  = 1:ncol(mat))

plot_df = merge(gene_index, plot_df, by = 'gene')
plot_df = merge(grna_index, plot_df, by = 'grna')

ggplot(plot_df) +
  geom_raster(aes(x = grna_idx, y = gene_idx, fill = estimate)) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  scale_fill_gradient2() +
  facet_wrap(vars(group), nrow=1) +
  theme_bw() 


pheatmap::pheatmap(tstat_matrix |> as.matrix(), treeheight_row = 0, treeheight_col = 0, 
                   cluster_rows = FALSE, cluster_cols = FALSE, 
                   color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100),
                   breaks = seq(from = -6, to = 6, length.out = 101),
                   show_rownames = FALSE, show_colnames = FALSE)
```

```{r}



#' Get the lo rank approximation of the given matrix (mat) using the 
#' given ranks (ranks)
#' @param mat (matrix) matrix to decompose
#' @param ranks (vector) of positive integers indicating the ranks
#' @param save_plots_filepath (string) or NULL for no plots
#' @param color_limits (vector) of length 2, for the limits of the colors 
#'     default = c(-2, 2), try to use integers... it looks ugly ow
#' @example
#' lowrankmatrices = approx_lowrank(
#'        mat = matrices$estimates,
#'        ranks = c(1, 3, 5, 10, 15),
#'        save_plots_filepath = '../plots/matrix/lowrank/estimate/',
#'        color_limits = c(-2, 2)
#' )
approx_lowrank <- function(mat, ranks, save_plots_filepath=NULL, color_limits = c(-2, 2)) {
  
  # save_plots_filepath = "../plots/matrix/lowrank/"
  # mat = matrices$estimates
  # mat |> as.matrix() |> as.vector() |> hist() # <- set limits to -2, 2
  
  # create some objects used for plotting later
  # - get a row and col order using clustering (marginally), for plotting later
  # - tall version of mat matrix
  if(!is.null(save_plots_filepath)) {
    matscaled = as.matrix(scale(mat))
    matscaled[is.nan(matscaled)] = 0
    row_order = hclust(dist(matscaled))$order
    column_order = hclust(dist(t(matscaled)))$order
    
    
    grna_index = data.frame(grna = rownames(mat)[row_order],
                            grna_idx  = 1:nrow(mat))
    gene_index = data.frame(gene = colnames(mat)[column_order],
                            gene_idx  = 1:ncol(mat))
    
    rm(matscaled, row_order, column_order)
    
      
    mat_tall = mat |> tibble::rownames_to_column('grna') |> 
        tidyr::pivot_longer(cols = 2:(ncol(mat)+1), 
                            names_to = 'gene', values_to = 'value') |>
        mutate(group = 'original')
    
    
    mat_tall = merge(gene_index, mat_tall, by = 'gene')
    mat_tall = merge(grna_index, mat_tall, by = 'grna')
    
    plot_df_all = mat_tall
    
    # color breaks for plotting
    color_breaks = sort(union(color_limits, seq(from = round(color_limits[1]), to = round(color_limits[2]))))
    color_breaks_label = color_breaks
    color_breaks_label[which.min(color_breaks)] = sprintf('<%.1f', min(color_breaks))
    color_breaks_label[which.max(color_breaks)] = sprintf('>%.1f', max(color_breaks))
  }
  
  
  # low rank approximation ---------------------------
  svd_res = svd(x = mat, nu = max(ranks), nv = max(ranks))
  
  
  if(!is.null(save_plots_filepath)) { # plot the singular values
    # svd_res$d |> plot()
    ggplot(NULL, aes(x = 1:length(svd_res$d),
               y = svd_res$d)) +
      geom_point() +
      labs(x = 'singular value #', y = 'singular value', 
           title = 'Singular Values') +
      theme_bw() +
      theme(panel.grid.minor = element_blank())
    ggsave(sprintf('%s/singularvalues.pdf', save_plots_filepath), height = 4, width = 6)
    
  }
  

  
  
  # rank = r <= max(ranks)
  lowrankmatrices = list()
  for(r in ranks) { # there is a faster ay by adding the ne eigenvecs to prev...but it is ok
    # approximation should be U D V^T
    if(r == 1) { # r drops the vector/matrix form...
      diag_singvals = matrix(svd_res$d[1], nrow=1, ncol=1)   
    } else {
      diag_singvals = diag(svd_res$d[1:r]) 
    }
    
    lowrank = svd_res$u[, 1:r, drop=FALSE] %*% diag_singvals %*% t(svd_res$v[, 1:r, drop=FALSE])
    colnames(lowrank) = colnames(mat)
    rownames(lowrank) = rownames(mat)
    
    lowrankmatrices[[r]] = lowrank
    
    # plot original vs lowrank (side by side)? or just the lowrank? i think just 1 at a time
    if(!is.null(save_plots_filepath)) {
      # create df for plotting 
      plot_df = lowrank |> as.data.frame() |> tibble::rownames_to_column('grna') |> 
            tidyr::pivot_longer(cols = 2:(ncol(lowrank)+1), 
                               names_to = 'gene', values_to = 'value') |>
            mutate(group = sprintf('rank=%02d', r))
      plot_df = merge(gene_index, plot_df, by = 'gene')
      plot_df = merge(grna_index, plot_df, by = 'grna')
      
      # one plot at a time
      ggplot(plot_df) +
        geom_raster(aes(x = grna_idx, y = gene_idx, fill = value)) +
        scale_x_continuous(expand = c(0, 0)) +
        scale_y_continuous(expand = c(0, 0)) +
        labs(x='grna', y = 'gene', fill = NULL) +
        scale_fill_gradient2(limits = color_limits, # set color limits
                             oob=scales::squish, # if outside lims, set to limits
                             midpoint = 0, 
                             breaks = color_breaks,
                             labels = color_breaks_label) +
        facet_wrap(vars(group), nrow=1) +
        theme_bw() +
        theme(strip.background = element_rect(fill = 'white'), 
              axis.ticks = element_blank(), 
              axis.text = element_blank(), 
              legend.position = 'bottom',
              legend.key.height = unit(.3, 'cm'),
              legend.key.width  = unit(1, 'cm'),
              legend.text = element_text(size = 7))
      
      ggsave(sprintf('%s/lowrank=%02d.pdf', save_plots_filepath, r), height = 6, width = 3)
      
      
      plot_df_all = rbind(plot_df_all, plot_df)
      
      
    }
  }
  
  
  # plot original and all lowrank approximations side by side
  if(!is.null(save_plots_filepath)) {
    
    plot_df_all$group = factor(
       plot_df_all$group, 
       levels = c('original', sprintf('rank=%02d', sort(ranks, decreasing=TRUE)))
    )
    
    # # one plot at a time
    # color_breaks = sort(union(color_limits, seq(from = round(color_limits[1]), to = round(color_limits[2]))))
    # color_breaks_label = color_breaks
    # color_breaks_label[which.min(color_breaks)] = sprintf('<%.1f', min(color_breaks))
    # color_breaks_label[which.max(color_breaks)] = sprintf('>%.1f', max(color_breaks))
    
    ggplot(plot_df_all) +
      geom_raster(aes(x = grna_idx, y = gene_idx, fill = value)) +
      scale_x_continuous(expand = c(0, 0)) +
      scale_y_continuous(expand = c(0, 0)) +
      labs(x='grna', y = 'gene', fill = NULL) +
      scale_fill_gradient2(limits = color_limits, # set color limits
                           oob=scales::squish, # if outside lims, set to limits
                           midpoint = 0,
                           # low  = brewer.pal(n = 9, name = "RdBu")[9],
                           # high = brewer.pal(n = 9, name = "RdBu")[1],
                           breaks = color_breaks,
                           labels = color_breaks_label) +
      facet_wrap(vars(group), nrow=1) +
      theme_bw() +
      theme(strip.background = element_rect(fill = 'white'), 
            panel.spacing = unit(.2, 'lines'),
            axis.ticks = element_blank(), 
            axis.text = element_blank(), 
            legend.position = 'bottom', 
            # legend.key.size = unit(.5, 'cm'),
            legend.key.height = unit(.3, 'cm'),
            legend.key.width  = unit(1.75, 'cm'),
            legend.text = element_text(size = 7))
    
    ggsave(sprintf('%s/lowrankall.pdf', save_plots_filepath), height = 6, width = 1.5*(length(ranks) + 1))
    
    
    # return the plot_df_all if it is created... (e.g. if the save plot file path is not NULL)
    # (want to return bc it is useful for shrinkage fn... should prob just make a function for
    #  matrix --> dataframe...)
    return(list(lowrankmatrices =lowrankmatrices,
                lowrankdataframe=plot_df_all))
  }

  

  
  return(list(lowrankmatrices=lowrankmatrices))
 
}




lowrankres = approx_lowrank(mat = matrices$estimates,
                                 ranks = c(1, 3, 5, 10, 15, 30),
                                 save_plots_filepath = '../plots/matrix/lowrank/estimate/',
                                 color_limits = c(-2, 2)) # matrices$estimates |> as.matrix() |> as.vector() |> hist()

lowrankres = approx_lowrank(mat = matrices$tstat,
                                 ranks = c(1, 3, 5, 10, 15, 30),
                                 save_plots_filepath = '../plots/matrix/lowrank/tstat/',
                                 color_limits = c(-4, 4)) # matrices$tstat |> as.matrix() |> as.vector() |> hist()

lowrankres = approx_lowrank(mat = matrices$significance,
                                 ranks = c(1, 3, 5, 10, 15, 30),
                                 save_plots_filepath = '../plots/matrix/lowrank/significance/',
                                 color_limits = c(-1, 1))

lowrankres = approx_lowrank(mat = matrices$foldchange,
                                 ranks = c(1, 3, 5, 10, 15, 30),
                                 save_plots_filepath = '../plots/matrix/lowrank/foldchange/',
                                 color_limits = c(0, 2)) # matrices$foldchange |> as.matrix() |> as.vector() |> hist()
 
lowrankres = approx_lowrank(mat = matrices$se,
                                 ranks = c(1, 3, 5, 10, 15, 30),
                                 save_plots_filepath = '../plots/matrix/lowrank/se/',
                                 color_limits = c(0, 3)) # matrices$se |> as.matrix() |> as.vector() |> hist()
 



```

```{r}
effects_df = effects_list$sceptre$all  |> filter(test == 'discovery') 

effects_df = effects_df |> filter((gene %in% (topgenes |> arrange(desc(score)) |> head(2000) |> pull(gene)))
                                  & 
                                  (grna %in% (topgrnas |> arrange(desc(score)) |> head(50) |> pull(grna))))

matrices = make_matrices(effects_df = effects_df)


PMD_fit = PMA::PMD(matrices$tstat |> as.matrix(), 
                type = 'standard', 
                sumabs = 1, sumabsu = 2, sumabsv = 2,
                niter = 50,
                K = 10, trace = FALSE)



sparseApprox = PMD_fit$u %*% diag(PMD_fit$d) %*% t(PMD_fit$v)


dim(sparseApprox)


methodParams = list(type = 'standard', 
                    sumabs = 1, sumabsu = 2, sumabsv = 2,
                    niter = 50,
                    K = 10, trace = FALSE)


sparseApprox = do.call(PMA::PMD,c(list(x=as.matrix(matrices$tstat)), methodParams)) 
sparseApprox$u
```




```{r}
library(microbenchmark)
set.seed(1)
m <- 1e4
n <- 1e3
k <- 3e2
X <- matrix(rnorm(m*k), nrow=m)
Y <- matrix(rnorm(n*k), ncol=n)

Z <- X %*% Y
rsparse::soft_svd(Z)

microbenchmark({
    Z <- X %*% Y
}, times=10L)




```



```{r}
# run one time

sparseSVD_estimate = approx_matrix(mat = matrices$estimates, 
              method = 'sparseSVD', 
              ranks = c(1, 3, 5, 10, 15, 30),
              # save_plots_filepath="../plots/matrix/sparseSVD/estimate/", 
              color_limits = c(-2, 2), 
              methodParams=list(type = 'standard', 
                                sumabs = .35,  # should be between 0-1, 
                                # sumabsu = 4, sumabsv = 4, # between 1 and sqrt(#col or #rows)
                                niter = 100,
                                trace = FALSE))



# unshrunk       = sparseSVD_estimate$approxdf |> dplyr::filter(group == 'original') |>
#                  dplyr::select(-group) |>
#                  dplyr::rename(unshrunk_point = value) 
unshrunk       = matrices$estimates |> tibble::rownames_to_column('grna') |>
                 tidyr::pivot_longer(cols = 2:(ncol(matrices$estimates)+1),
                                     names_to = 'gene', values_to = 'unshrunk_value')


# shrinkagepoint = sparseSVD_estimate$approxdf |> dplyr::filter(group == 'rank=15') |> 
#                  dplyr::select(grna, gene, value) |> 
#                  dplyr::rename(shrinkage_point = value)
shrinkagepoint = sparseSVD_estimate$approxmatrices[[15]] |> as.data.frame() |>
                 tibble::rownames_to_column('grna') |>
                 tidyr::pivot_longer(cols = 2:(ncol(sparseSVD_estimate$approxmatrices[[15]])+1),
                                     names_to = 'gene', values_to = 'shrinkage_point')

se             = matrices$se |> tibble::rownames_to_column('grna') |> 
                 tidyr::pivot_longer(cols = 2:(ncol(matrices$se)+1), 
                                     names_to = 'gene', values_to = 'se')


ebci_data = merge(merge(unshrunk, shrinkagepoint, 
                        by = c('grna', 'gene')),
                  se, by = c('grna', 'gene'))

head(ebci_data)

# some se's ere undefined and set to 999, prob too large, set to max
# hist(pmin(ebci_data$se, quantile(ebci_data$se, .91))) # 1.744747
# hist(pmin(ebci_data$se, max(ebci_data$se[ebci_data$se<999]))) # 102.1838
# 
# ebci_data$se = pmin(ebci_data$se, max(ebci_data$se[ebci_data$se<999]))
ebci_data$se = pmin(ebci_data$se, quantile(ebci_data$se, .91))

t0 = Sys.time()
ebci_obj = ebci::ebci(formula = sprintf('%s - shrinkage_point ~ 0', 'unshrunk_value'),
                  # formula = 'tstat - shrinkage_point ~ 0', # ebci_formula
                  data    = ebci_data |> head(300), 
                  # se = eval(parse(text = se_colname)), 
                  # weights =  eval(parse(text = sprintf('1/%s^2', se_colname))), 
                  se = se,
                  # weights = 1/nrow(ebci_data),
                  alpha = .1)
t1 = Sys.time(); print(t1 - t0)


ebci_obj


ebci_res = ebci_data |> 
           head(nrow(ebci_obj$df)) |>
           dplyr::mutate(shrunk_value = ebci_obj$df$th_eb + shrinkage_point,
                         lower_ci = shrunk_value - ebci_obj$df$len_eb,
                         upper_ci = shrunk_value + ebci_obj$df$len_eb)
dim(ebci_res)
head(ebci_res)


hist(ebci_res$se)

hist(ebci_res$shrinkage_point)

# plot shrunk vs unshrunk
ggplot(ebci_res) +
  geom_abline(aes(slope = 1, intercept = 0), color = 'gray') +
  geom_point(aes(x = unshrunk_value, y = shrunk_value, color = se)) +
  theme_classic()

# plot shrunk vs unshrunk centered
ggplot(ebci_res) +
  geom_abline(aes(slope = 1, intercept = 0), color = 'gray') +
  geom_point(aes(x = unshrunk_value - shrinkage_point, y = shrunk_value - shrinkage_point, color = se)) +
  theme_classic()

# plot unshrunk vs shrinkage point
ggplot(ebci_res) +
  geom_abline(aes(slope = 1, intercept = 0), color = 'gray') +
  geom_point(aes(x = unshrunk_value, y = shrinkage_point, color = se)) +
  theme_classic()


```
